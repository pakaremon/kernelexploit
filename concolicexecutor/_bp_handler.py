import colorama
from ..pwntools.pwn import *
import time
import angr


class BPHandlerMixin:
    def track_symbolic_variable(self, state):
        print('Symbolic_Variable:', state.inspect.symbolic_name, 'size:', \
                state.inspect.symbolic_size, 'symbolic expr:', \
                state.inspect.symbolic_expr)
        return

    def track_bp(self, state):
        self.debug_state(state)
        import IPython; IPython.embed()
        return


    def track_reads(self, state):
        if state.regs.rip.symbolic:  # we do not handle read when rip is symbolic
            return
        b = self.b
        sol = self.sol
        print('='*78)
        print('Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address,\
            'Size', state.inspect.mem_read_length)
        if type(state.inspect.mem_read_address) is not int:
            try:
                if self.debug_irsb:
                    irsb = b.factory.block(state.addr).vex
                    irsb.pp()
                cap = b.factory.block(state.addr).capstone
                cap.pp()
                self.dump_reg(state)
                print('uninit:', state.inspect.mem_read_address.uninitialized,\
                    'symbolic:', state.inspect.mem_read_address.symbolic)
                if state.inspect.mem_read_address.symbolic:
                    print('read from symbolic address, primitive found!')
                    if self.pause_on_read_from_symbolic_address:
                        input('wtf read from symbolic address')
                    return
                print('checking whether memory is uninitialized...')
                t=state.memory.load(state.inspect.mem_read_address,size=1,inspect=False)
                if (t.uninitialized and not state.inspect.mem_read_address.symbolic):
                    print('memory content uninit: ', t.uninitialized,\
                        'memory content symbolic: ', t.symbolic)
                    print('[+] uninitialized memory read found:', state.inspect.mem_read_address)
                    print('[+] the uninitialized memory read is at:', hex(state.addr))
                    if self.resolve_uninit:
                        r = remote('127.0.0.1', self.qemu_port)
                        addr = self.sol.eval(state.inspect.mem_read_address.get_bytes(0,8),1)[0]
                        print('[+] resolving a page containing the address:', hex(addr))
                        con = self.statebroker.get_a_page(r, addr)
                        r.close()
                        if con != None:
                            self.set_concret_memory_region(state, addr, con, 4096)
                            print('[+] resolved the uninit with concrete page')
                        else:
                            print( '[!] failed to resolve the uninit memory')
                            if self.pause_on_failed_memory_resolving:
                                import IPython; IPython.embed()
                        #import IPython; IPython.embed()
                        if self.pause_on_finish_memory_loading:
                            input('do the read now(continue) <-')
                else:
                    print('Memory Content does not appear uninitialized.')
            except AttributeError as e:
                print(e.args, e.message)
                print('wtf track reads')
                import IPython; IPython.embed()
                pass
            except angr.errors.SimValueError as e:
                print('wtf simvalueerror')
                import IPython; IPython.embed()

        else:
            import IPython; IPython.embed()
        return

    def track_writes(self, state):
        b=self.b
        claripy = self.claripy
        print('='*78)
        print('Write', state.inspect.mem_write_expr, 'to', state.inspect.mem_write_address,\
            'size', state.inspect.mem_write_length,\
            'Write target type:', type(state.inspect.mem_write_address))
        if self.debug_irsb:
            irsb = b.factory.block(state.addr).vex
            irsb.pp()
        cap = b.factory.block(state.addr).capstone
        cap.pp()
        self.dump_reg(state)
        #if type(state.inspect.mem_write_address) not in [long, self.typebv]:
        if type(state.inspect.mem_write_address) not in [int]\
                and state.inspect.mem_write_address.symbolic:
            print('symbolic write?')
            try:
                print('target uninit:',state.inspect.mem_write_address.uninitialized,\
                    'target symbolic',state.inspect.mem_write_address.symbolic)
                if state.inspect.mem_write_address.symbolic:
                    print('[+] write to symbolic address, primitive found!')
                    if state.addr not in self.seen_symbolic_write_primitive_addr:
                        self.seen_symbolic_write_primitive_addr.append(state.addr)
                        s=state.copy()
                        self.write_to_symbolic_address_primitive.append(\
                            {'state':s\
                            ,'timestamp':time.time()\
                            })

                    if self.pause_on_write_to_symbolic_address:
                        opt=input('ipython shell? [y/n]')
                        if opt=='y\n':
                            import IPython; IPython.embed()
                if state.inspect.mem_write_address.uninitialized:
                    print('write to uninitialized address, primitive found!')
                    if self.pause_on_uninit_write:
                        input('wtf uninitialzed write')
            except AttributeError as e:
                print(e.args, e.message)
                print('wtf track writes')
                import IPython; IPython.embed()
                pass
            print('end symbolic write')
        else:
            print('normal write...')
            write_address = self.sol.eval(state.inspect.mem_write_address, 1)[0]
            if (write_address >= self.uaf_object_base)\
                    and (write_address <= self.uaf_object_base + self.uaf_object_size):
                print('uaf_object_base', hex(self.uaf_object_base))
                print((colorama.Fore.RED + '[+] found an write_to_uaf_object primitive' + colorama.Style.RESET_ALL))
                if state.addr not in self.seen_write_to_uaf_object_primitive_addr:
                    self.seen_write_to_uaf_object_primitive_addr.append(state.addr)
                    s = state.copy()
                    new_write_to_uaf_primitive={'state': s
                            , 'in_object_offset_to_write': state.inspect.mem_write_address - self.uaf_object_base
                            , 'expr_to_write': state.inspect.mem_write_expr
                            , 'address_to_write': state.inspect.mem_write_address
                            , 'size_to_write': state.inspect.mem_write_length
                            , 'timestamp': time.time()
                            }
                    self.write_to_uaf_object_primitive.append(new_write_to_uaf_primitive)
                    # try heap meta exploit
                    self.try_heap_metadata_exploit(self.write_to_uaf_object_primitive[-1])
                if self.pause_on_write_to_uaf_object_primitive:
                    opt=input('ipython shell? [y/n]')
                    if opt == 'y\n':
                        import IPython; IPython.embed()
            print('end normal write...')
        #import IPython; IPython.embed()
        return

    def track_call_bk(self, state):
        """
        in this callback, we can not use state.addr to get current ip as it might be symbolic,
        if the rip is symbolic, we have found an exploitable primitive
        """
        print(('='*78))
        print(('Call instruction at:', state.inspect.function_address))
        if state.regs.rip.symbolic:  # found symbolic instruction pointer
            print((colorama.Fore.RED + '[+] control flow hijack found' + colorama.Style.RESET_ALL))
            self.add_stack_pivot_constraint(state)
            if self.pause_on_control_flow_hijack:
                opt = input('ipython shell? [y/N]')
                if opt == 'y\n':
                    import IPython; IPython.embed()
        else:
            # detecting other control hijack primitives
            print('rip', state.regs.rip)
            if self.detect_rcu_free and self.interested_funcs != {}:
                rcu_free = self.interested_funcs['kfree_call_rcu']
                if self.sol.eval(state.regs.rip,1)[0]==rcu_free and state.regs.rdi.symbolic:
                    print((colorama.Fore.RED + '[+] symbolic rcu_free found' + colorama.Style.RESET_ALL))
                    primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                    if state.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
                        self.seen_control_flow_hijack_primitive.append(state.history.bbl_addrs[-1])
                        self.control_flow_hijack_primitive.append(primitive)#add current state to CF hijack primitve

            # detecting memory leak
            if self.detect_memory_leak and len(self.memory_leak_funcs) != 0:
                for key in self.memory_leak_funcs:
                    value = self.memory_leak_funcs[key]
                    if self.sol.eval(state.regs.rip,1)[0] == value and state.regs.rax.symbolic:
                        print((colorama.Fore.RED + '[+] memory leak found' + colorama.Style.RESET_ALL))
                        primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                        if state.history.bbl_addrs[-1] not in self.seen_memory_leak_primitive:
                            self.seen_memory_leak_primitive.append(state.history.bbl_addrs[-1])
                            self.memory_leak_primitive.append(primitive)

        # raw_input('track_call')
        return

    def track_call(self, state):
        if not state.regs.rip.symbolic:
            print('rip', state.regs.rip)
            if self.detect_rcu_free and self.interested_funcs != {}:
                rcu_free = self.interested_funcs['kfree_call_rcu']
                if self.sol.eval(state.regs.rip,1)[0]==rcu_free and state.regs.rdi.symbolic:
                    print((colorama.Fore.RED + '[+] symbolic rcu_free found' + colorama.Style.RESET_ALL))
                    primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                    if state.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
                        self.seen_control_flow_hijack_primitive.append(state.history.bbl_addrs[-1])
                        self.control_flow_hijack_primitive.append(primitive)#add current state to CF hijack primitve

            # detecting memory leak
            if self.detect_memory_leak and len(self.memory_leak_funcs) != 0:
                for key in self.memory_leak_funcs:
                    value = self.memory_leak_funcs[key]
                    if self.sol.eval(state.regs.rip,1)[0] == value and state.regs.rax.symbolic:
                        print((colorama.Fore.RED + '[+] memory leak found' + colorama.Style.RESET_ALL))
                        primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                        if state.history.bbl_addrs[-1] not in self.seen_memory_leak_primitive:
                            self.seen_memory_leak_primitive.append(state.history.bbl_addrs[-1])
                            self.memory_leak_primitive.append(primitive)



    def address_concretization_before(self, state):
        print(('=' * 5 + 'Before concretizing address' + '=' * 5))
        print('state.addr', hex(state.addr))
        print('Address_Concretization strategy:', \
            state.inspect.address_concretization_strategy)
        print('Address concretization action:', \
            state.inspect.address_concretization_action)
        print('address_concretization_memory:', \
            state.inspect.address_concretization_memory)
        print('address_concretization_expr:', \
            state.inspect.address_concretization_expr)
        return

    def address_concretization_after(self, state):
        print('=====After address concretization=====')
        print('address_concretization_result:', \
            state.inspect.address_concretization_result)
        if state.inspect.address_concretization_action == 'load':
            print('address_concretization_action: load')
        print('=====End of concretization=====')
        if self.debug_after_address_concretization:
            opt = input('ipython shell? [y/N]')
            if opt == 'y\n':
                import IPython;
                IPython.embed()

    def concretization_cond(self, state):
        return state.addr == 0xffffffff8109a62a

    def concretization_cond_15649(self, state):
        return state.addr == 0xffffffff81788a57

    def concretization_cond_0728(self, state):
        return state.addr == 0xffffffff812d86ae  # <key_revoke+30>:   mov    rax,QWORD PTR [rbx+0x80]

    def concretize_call_before(self, state):
        print(('=' * 78))
        print(('Address_Concretization strategy:', \
              state.inspect.address_concretization_strategy))
        print(('Address_Concretization action:', \
              state.inspect.address_concretization_action))
        print(('Address_Concretization memory:', \
              state.inspect.address_concretization_memory))
        print(('Address_Concretization expr:', \
              state.inspect.address_concretization_expr))
        # raw_input()
        return

    def concretize_call_after(self, state):
        print(('=' * 78))
        print(('Address_Concretization strategy:', \
              state.inspect.address_concretization_strategy))
        print(('address_concretization_result:', \
              state.inspect.address_concretization_result))
        if state.inspect.address_concretization_action == 'load':
            print ('address_concretization_action: load')
        opt = input('ipython shell? [y/N]')
        if opt == 'y\n':
            import IPython;
            IPython.embed()
        return

