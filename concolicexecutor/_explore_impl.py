# author: ww9210
import angr
import time
import traceback
import colorama


class ExploreImplMixin:
    def explore_by_pathgroup(self, s):
        sol = self.sol
        b = self.b
        simgr = b.factory.simgr(s, save_unconstrained=True)
        simgr.stashes['exploitable_state'] = []
        simgr.stashes['old_ucstate'] = []
        if self.limit_loop:
            llimiter = angr.exploration_techniques.LoopLimiter(count=5)
            simgr.use_technique(llimiter)
        loop_idx = 0
        while True:
            current_time = time.time()
            if current_time - self.start_time_of_symbolic_execution > self.execution_time_limit:
                print('[+] symbolic execution timeup, harvest now')
                self.dump_all_primitives()
                import IPython; IPython.embed()
                return

            print('[+] '+str(loop_idx) + ' step()')
            self.debug_simgr(simgr)
            try:
                simgr.step()
            except:
                print('wtf simgr error')
                traceback.print_exc()
                import IPython; IPython.embed()
                return
            loop_idx += 1
            if len(simgr.active) == 0:
                print('no active states left, game over..')
                import IPython; IPython.embed()
                return
            if simgr.unconstrained:
                for ucstate in simgr.unconstrained:
                    print('[+] unconstrained state found!')
                    print('Call instruction at:', ucstate.history)
                    print(colorama.Fore.RED + '[+] control flow hijack found' + colorama.Style.RESET_ALL)
                    # try stack pivot and rop to bypass SMEP
                    new_state = self.add_stack_pivot_constraint(ucstate)
                    if new_state is not None and new_state.satisfiable():
                        simgr.stashes['exploitable_state'].append(new_state)

                    if self.look_for_second_control_flow_hijack:
                        self.look_for_second_control_flow_hijack = False
                        # check for second control flow hijack by forking many states
                        affected_registers = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11'
                                              , 'r12', 'r13', 'r14', 'r15']
                        for affected_register in affected_registers:
                            try:
                                tmp_state = ucstate.copy()
                                old_value = tmp_state.registers.load(affected_register, 64, inspect=False)
                                if old_value.symbolic:  # do not fork if the old value is already symbolic
                                    continue
                                ret_addr = tmp_state.stack_pop()  # get the return address
                                tmp_state.regs.rip = ret_addr
                                new_reg_val = tmp_state.se.BVS('my'+affected_register, 64)
                                tmp_state.registers.store(affected_register, new_reg_val)
                                simgr.active.append(tmp_state)
                                print('volatile states added')
                            except:
                                traceback.print_exc()
                                import IPython; IPython.embed()


                    if self.pause_on_control_flow_hijack:
                        opt = input('ipython shell? [y/N]')
                        if opt == 'y\n':
                            import IPython; IPython.embed()
                    simgr.stashes['old_ucstate'].append(ucstate.copy())
                    simgr.unconstrained.remove(ucstate)


            if simgr.errored:
                print('[!] errored state found')
                import IPython; IPython.embed()
            # inspect strange state that has rip not in kernel code space
            def my_filter_func(somestate):
                """
                helper function to filter meaningless states out
                :param somestate:
                :return:
                """
                if somestate.ip.symbolic:
                    return True
                ip = sol.eval(somestate.ip, 1)[0]
                if ip < 0xffffffff81000000:
                    return True
                if ip in [0xffff880066800000, 0]:
                    return True
                if ip < 0x7fffffffffff:
                    return True
                return False

            for state in simgr.active:
                if my_filter_func(state):
                    self.debug_state(state)
                    print('strange state, found...')
                    if self.pause_on_strange_state:
                        import IPython; IPython.embed()

            simgr.move(from_stash='active', to_stash='deadended', filter_func=my_filter_func)

            if self.pause_on_each_step:
                print('step?<-')
                import IPython; IPython.embed()

