from itertools import groupby

from . import SimConcretizationStrategy

class SimConcretizationStrategyKuafffp2(SimConcretizationStrategy):
    """
    Concretization strategy of a more conservative concretization
    It is a stateful concretization strategy
    blooming concretization strategy
        |-------------range of symbolic memory------------|
    1st |-------------------*****-------------------------|
    2nd |---------------*************---------------------|
    3nd |------------********************-----------------|

    *: possible value range

    """
    def __init__(self, mapped_addr, length=4096, step=0x100, times_of_concretization=1, limit=1, **kwargs):
        super(SimConcretizationStrategyKuafffp2, self).__init__(**kwargs)
        self._mapped_addr = mapped_addr
        self._length = length
        self._step = step
        self._times_of_concretization = times_of_concretization
        self._limit = limit

    def _concretize(self, memory, addr):
        intervals = []
        start = self._mapped_addr + self._length/2 - self._times_of_concretization * self._step
        end = self._mapped_addr + self._length/2 + self._times_of_concretization * self._step
        intervals.append([start, end])
        constraints = []
        for intv_start, intv_end in intervals:
            print 'kuafffp debug:', hex(intv_start), hex(intv_end)
            constraints.append(memory.state.se.And(addr < intv_end, addr >= intv_start))
        solutions = self._eval(memory, addr, self._limit, extra_constraints=constraints)
        if not solutions:
            solutions = None
        else:
            self._times_of_concretization += 1
        return solutions

    def copy(self):
        return SimConcretizationStrategyKuafffp2(
            mapped_addr=self._mapped_addr,
            length=self._length,
            step=self._step,
            times_of_concretization=self._times_of_concretization,
            limit=self._limit,
        )
