# Kernel Exploit Project NT513.O11.ANTT class # 

## Mô tả ##
Đây là 1 dự án fuzzing tìm bug trong kernel linux phiên bản 4.19. Nội dung dự án này được dựa trên bài báo [đây](https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-wu_0.pdf) Mục đích của dự án này nhằm giúp hỗ trợ các nhà nghiên cứu tìm ra lỗ hổng user-after-free trong nhân kernel. Dự án này sử dụng hai công cụ chính là [syzkaller](https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md) và [angr](https://github.com/angr/angr)

## Mục lục
1. [Tổng quan](#abstract)
2. [Phương pháp](#methodology)
3. [Môi trường thực nghiệm](#environment)
4. [Kết quả thực nghiệm](#result)


### abstract
Lỗ hổng Use-After-Free là một lỗi bảo mật bộ nhớ đặc biệt, có thể gây hỏng dữ liệu hợp lệ và dẫn đến khả năng thực thi mã tùy ý. Khi lỗ hổng này xảy ra trong hạt nhân hệ điều hành, nó có thể dẫn đến việc leo thang đặc quyền và rò rỉ dữ liệu quan trọng. Để khai thác lỗ hổng Use-After-Free, đặc biệt là trong kernel hệ điều hành, kẻ tấn công cần xác định thời điểm mà một đối tượng được giải phóng để có thể thay đổi dữ liệu trong vùng nhớ đó và từ đó thực hiện hành động phù hợp. Họ cũng cần tận dụng kiến thức chuyên môn của mình để điều chỉnh thủ công các lệnh gọi hệ thống và các đối số tương ứng, dựa trên kích thước và loại bộ nhớ được cấp phát (heap).
Bài báo đề xuất FUZE, một khung công cụ khai thác (exploitation framework) nhằm đánh giá khả khai thác của các lỗ hổng Use-After-Free trong hạt nhân. Về nguyên tắc, framework này  nhằm đạt được việc đánh giá khả khai thác bằng cách tự động khám phá khả năng khai thác của một lỗ hổng. Tuy nhiên, kỹ thuật của họ tuân thủ một thiết kế hoàn toàn khác biệt, sử dụng một kỹ thuật fuzzing để đa dạng hóa ngữ cảnh của kernel panic và sau đó sử dụng symbolic execution để khám phá khả năng khai thác khác nhau trong các ngữ cảnh đó. (Kernel panic là một trạng thái nghiêm trọng xảy ra trong kernel của hệ điều hành khi gặp phải một lỗi nghiêm trọng hoặc không thể xử lý được. Trong trạng thái kernel panic, kernel không còn khả năng hoạt động đúng và không thể tiếp tục thực thi công việc. )
Cụ thể hơn, hệ thống của họ trước tiên nhận một chương trình PoC (Proof-of-Concept) làm đầu vào, chương trình này không thực hiện khai thác nhưng gây ra kernel panic. Sau đó, họ sử dụng kernel fuzzing để khám phá các lệnh gọi hệ thống khác nhau và từ đó biến đổi ngữ cảnh của kernel panic. Dưới mỗi ngữ cảnh liên quan đến một kernel panic riêng biệt, FUZE tiếp tục thực hiện symbolic execution với mục tiêu tìm ra các nguyên tố có tiềm năng để khai thác. Để xác định những yếu tố thực sự có giá trị để khai thác một lỗ hổng Use-After-Free và thậm chí vượt qua các biện pháp bảo mật, FUZE tóm tắt một tập hợp các phương pháp khai thác thường được áp dụng và sau đó sử dụng chúng để đánh giá các yếu tố tương ứng.

### methodology
#### bước1 khai thác thông tin
Đầu tiên chúng ta sẽ mô tả trước cách FUZE trích xuất thông tin cần thiết để tạo điều kiện cho việc khai thác. Tiếp theo là mô tả cách FUZE sử dụng thông tin này để khởi tạo các ngữ cảnh chạy, thực hiện kiểm tra nhanh kernel và từ đó đạt được sự biến đổi ngữ cảnh (sự biến đổi ngữ cảnh trong khai thác lỗ hổng UAF là quá trình thay đổi và thích nghi các ngữ cảnh thực thi để tận dụng lỗ hổng một cách hiệu quả và tránh các biện pháp bảo mật). Tiếp theo, chúng ta xác định cách FUZE thực hiện thực thi tượng trưng(symbolic execution: là một kỹ thuật trong lĩnh vực kiểm thử phần mềm và bảo mật, được sử dụng để tự động tạo ra các đầu vào đặc biệt để khám phá các đường dẫn thực thi khác nhau trong chương trình hoặc hệ thống), xác định các trạng thái máy có thể khai thác và từ đó đánh giá ngữ cảnh cũng như tính toán dữ liệu được chèn
FUZE nhận vào một chương trình PoC làm đầu vào. Sau đó, nó trích xuất thông tin cần thiết để khai thác liên tiếp bằng cách sử dụng công cụ kiểm tra địa chỉ kernel KASAN cùng với cơ chế theo dõi động (Dynamic Tracing).
Thông tin từ Kernel Address Sanitizer: KASAN là một công cụ kiểm tra địa chỉ kernel, cung cấp cho chúng ta khả năng thu thập thông tin liên quan đến lỗ hổng. Cụ thể, bao gồm địa chỉ cơ sở và kích thước của một đối tượng có lỗ hổng, câu lệnh chương trình liên quan đến vị trí giải phóng một con trỏ treo và câu lệnh chương trình tương ứng với vị trí giải phóng con trỏ treo. (Vị trí giải phóng con trỏ treo là một con trỏ đã bị giải phóng vẫn còn một vị trí trong bộ nhớ. Điều này xảy ra khi một con trỏ được giải phóng, nhưng không có bất kỳ biện pháp nào để xóa hoặc ghi đè lên vị trí đó trong bộ nhớ. Kết quả là, con trỏ trở thành một "con trỏ treo" với một vị trí không hợp lệ trong bộ nhớ)
Thiết kế của Dynamic Tracing: Ngoài thông tin được trích xuất thông qua KASAN, khai thác liên tiếp cần thông tin về việc thực thi các cuộc gọi hệ thống gây ra lỗ hổng. Một cơ chế theo dõi động được tạo ra, trước tiên theo dõi các địa chỉ của bộ nhớ được cấp và giải phóng trong kernel Linux cũng như các định danh quá trình (PID) được gắn kết với các hoạt động quản lý bộ nhớ này. Bằng cách này có thể kích hoạt việc theo dõi quản lý bộ nhớ và liên kết các hoạt động quản lý bộ nhớ với chương trình PoC. Thứ hai là tạo công cụ instrument cho chương trình PoC với trình theo dõi nội bộ kernel Linux (ftrace). Điều này cho phép thu thập thông tin liên quan đến các cuộc gọi hệ thống được gọi bởi chương trình PoC.
#### Bước2 Kernel Fuzzing
Kernel fuzzing đưa vào kernel các dữ liệu đầu vào ngẫu nhiên, không hợp lệ hoặc bất thường để tạo ra các tình huống không mong muốn và kiểm tra phản ứng của kernel đối với chúng.
Để khởi tạo ngữ cảnh fuzzing, cần xác định vị trí xảy ra con trỏ treo và vị trí con trỏ được giải phóng. Điều này có thể được thực hiện bằng cách sử dụng các công cụ như KASAN (Kernel Address Sanitizer) và dynamic tracing.
Sau khi xác định được hai vị trí này, cần gói(bọc) chương trình PoC thành một hàm độc lập. Điều này sẽ giúp ngăn chặn chương trình PoC truy cập đến vị trí giải phóng con trỏ treo, điều này có thể gây ra sự cố trong kernel. Cần chèn mã vào hàm PoC để kích hoạt giải phóng bộ nhớ nhưng không truy cập đến vị trí giải phóng con trỏ treo. Điều này có thể được thực hiện bằng cách sử dụng lệnh return hoặc system call ioctl.

Sau khi khởi tạo ngữ cảnh fuzzing, có thể bắt đầu fuzzing kernel. Để làm điều này, cần sử dụng một framework fuzzing kernel hiện đại. Framework này sẽ ngẫu nhiên thay đổi các tham số của các cuộc gọi hệ thống và theo dõi xem liệu các thay đổi này có dẫn đến bất kỳ sự cố nào hay không.
Có thể thiết lập framework fuzzing kernel theo hai cách:
-	Bắt đầu fuzzing kernel ngay sau khi khởi tạo ngữ cảnh fuzzing: Vì đã gói một chương trình PoC được trang bị công cụ như một hàm độc lập nên có thể dễ dàng đạt được điều này bằng cách gọi hàm gói trước khi thực hiện kernel fuzzing.
-	Thiết lập fuzzing framework để thực hiện fuzz testing đồng thời
Có thể cải thiện hiệu quả của framework fuzzing kernel bằng cách cho phép chia sẻ tham số giữa ngữ cảnh ban đầu và framework fuzzing. Điều này sẽ giúp framework fuzzing tập trung vào các tham số có khả năng gây ra sự cố.
Có thể giảm thiểu số lượng cuộc gọi hệ thống cần kiểm tra bằng cách sử dụng thông tin từ phân tích lỗ hổng. Ví dụ, nếu lỗ hổng bảo mật liên quan đến một đối tượng cụ thể, có thể chỉ cần kiểm tra các cuộc gọi hệ thống liên quan đến đối tượng đó.
#### Bước 3: Symbolic execution
Thực thi tượng trưng (symbolic execution) là một kỹ thuật trong lĩnh vực kiểm thử phần mềm và bảo mật, được sử dụng để tự động tạo ra các đầu vào đặc biệt để khám phá các đường dẫn thực thi khác nhau trong chương trình hoặc hệ thống.
Fuze sử dụng thông tin thu được từ KASAN và dynamic tracing để xác định vị trí giải phóng con trỏ treo. Fuze đặt breakpoint tại vị trí đó và bắt đầu thực thi tượng trưng (Symbolic Execution). Nếu không quan sát thấy đối tượng đã giải phóng, Fuze sẽ buộc kernel tiếp tục thực thi. Ngược lại, Fuze sẽ tạm dừng thực thi kernel và sử dụng nó làm cài đặt ban đầu cho việc thực thi tượng trưng (Symbolic Execution) liên tiếp.

Fuze tạo các giá trị biểu tượng cho mỗi byte của đối tượng đã giải phóng. Fuze tiếp tục thực thi kernel theo tượng trưng và tìm kiếm các “Primitive”: hijacking luồng điều khiển (cho phép kiểm soát luồng thực thi kernel) và ghi không hợp lệ (cho phép thao tác vùng nhớ kernel). Do các hoạt động “Primitive” chỉ thể hiện các hoạt động cần thiết nói chung cho việc khai thác chứ không phản ánh khả năng của chúng trong việc hỗ trợ việc khai thác nên nếu Fuze tìm thấy một “Primitive” thuộc một trong hai loại này, nó sẽ đánh giá “Primitive” dựa trên các phương pháp khai thác thường được áp dụng. Khi “Primitive” vượt qua đánh giá, Fuze sẽ coi đó là một trạng thái khai thác được.

### environment

#### kernel fuzzing:
  - Hệ điều hành window 10, 64 bit, Ram 16G, CPU intel 5 thế hệ 10 có hỗ triwj KVM(dùng tăng tốc quá trình fuzzing của syzkaller) 
  - Sử dụng WSL (window system linux) để chạy syzakaller.
  - Quá trình cài được thực hiện theo hướng dẫn tại [đây](https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md)
- Để sử dụng KASAN và Ftrace để theo dõi bug trong kernel, thì tại quá trình tạo kernel cần bật tính năng sau tại file .config
  ```CONFIG_KASAN=y CONFIG_KASAN_INLINE=y ```

#### symbolic execution 
  - Sử dụng máy ảo Ubuntu 20.04, 64bit, Ram 16G.
  - Sử dụng [neo4j](https://hub.docker.com/_/neo4j/) trên docker.
  - Công cụ angr.
    
### result

#### kernel fuzzing
Kết quả quá trình kernel fuzzing trên window.
![image](https://github.com/pakaremon/kernelexploit/assets/98400336/6200780d-42ae-45d1-b86a-980c2728e741)
Quá trình ghi log của syzkaller.
![image](https://github.com/pakaremon/kernelexploit/assets/98400336/ff8cd58b-7258-4cea-9116-a8ee7443886b)


Quá trình kernel fuzzing trên [syzbot](https://syzkaller.appspot.com/upstream) một cộng cụ fuzzing trên cloud của Google.
![image](https://github.com/pakaremon/kernelexploit/assets/98400336/418ed4f8-36ac-4d24-9176-6815707235ee)
Kết quả quá trình fuzzing cho ta biết tên lỗ hổng, đoạn code gây nên lỗ hổng trong kernel.
![image](https://github.com/pakaremon/kernelexploit/assets/98400336/48781d6d-3a65-4b87-896d-f0ca46b0058a)


